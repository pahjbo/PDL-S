/*
* generated by Xtext
*/
package net.ivoa.pdl.pdls.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class PdlsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class PDLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PDL");
		private final RuleCall cServiceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * domain specific language for PDL
		// * / PDL:
		//	Service;
		public ParserRule getRule() { return rule; }

		//Service
		public RuleCall getServiceParserRuleCall() { return cServiceParserRuleCall; }
	}

	public class ServiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Service");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cServiceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cParametersKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cParametersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cParametersParameterParserRuleCall_5_0 = (RuleCall)cParametersAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cInputKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cLeftCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cInputsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cInputsParameterGroupParserRuleCall_9_0 = (RuleCall)cInputsAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cOutputKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Keyword cLeftCurlyBracketKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Assignment cOutputsAssignment_13 = (Assignment)cGroup.eContents().get(13);
		private final RuleCall cOutputsParameterGroupParserRuleCall_13_0 = (RuleCall)cOutputsAssignment_13.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cRightCurlyBracketKeyword_15 = (Keyword)cGroup.eContents().get(15);
		
		//Service:
		//	"service" name=ID "{" "parameters" "{" parameters+=Parameter+ "}" "input" "{" inputs+=ParameterGroup* "}" "output" "{"
		//	outputs+=ParameterGroup* "}" "}";
		public ParserRule getRule() { return rule; }

		//"service" name=ID "{" "parameters" "{" parameters+=Parameter+ "}" "input" "{" inputs+=ParameterGroup* "}" "output" "{"
		//outputs+=ParameterGroup* "}" "}"
		public Group getGroup() { return cGroup; }

		//"service"
		public Keyword getServiceKeyword_0() { return cServiceKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//"parameters"
		public Keyword getParametersKeyword_3() { return cParametersKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//parameters+=Parameter+
		public Assignment getParametersAssignment_5() { return cParametersAssignment_5; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_5_0() { return cParametersParameterParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }

		//"input"
		public Keyword getInputKeyword_7() { return cInputKeyword_7; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_8() { return cLeftCurlyBracketKeyword_8; }

		//inputs+=ParameterGroup*
		public Assignment getInputsAssignment_9() { return cInputsAssignment_9; }

		//ParameterGroup
		public RuleCall getInputsParameterGroupParserRuleCall_9_0() { return cInputsParameterGroupParserRuleCall_9_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }

		//"output"
		public Keyword getOutputKeyword_11() { return cOutputKeyword_11; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_12() { return cLeftCurlyBracketKeyword_12; }

		//outputs+=ParameterGroup*
		public Assignment getOutputsAssignment_13() { return cOutputsAssignment_13; }

		//ParameterGroup
		public RuleCall getOutputsParameterGroupParserRuleCall_13_0() { return cOutputsParameterGroupParserRuleCall_13_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_14() { return cRightCurlyBracketKeyword_14; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_15() { return cRightCurlyBracketKeyword_15; }
	}

	public class ParameterIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterID");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * * / ParameterID:
		//	ID;
		public ParserRule getRule() { return rule; }

		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameParameterIDParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeParameterTypeEnumRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * include restriction of always conditional statement as convenience to ba applied everywhere - should not reference other parameters * /
		//Parameter:
		//	name=ParameterID ":" type=ParameterType ";";
		public ParserRule getRule() { return rule; }

		//name=ParameterID ":" type=ParameterType ";"
		public Group getGroup() { return cGroup; }

		//name=ParameterID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ParameterID
		public RuleCall getNameParameterIDParserRuleCall_0_0() { return cNameParameterIDParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=ParameterType
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//ParameterType
		public RuleCall getTypeParameterTypeEnumRuleCall_2_0() { return cTypeParameterTypeEnumRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ParameterGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGroupKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cParamsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cParamsAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final CrossReference cParamsParameterCrossReference_3_2_0 = (CrossReference)cParamsAssignment_3_2.eContents().get(0);
		private final RuleCall cParamsParameterParameterIDParserRuleCall_3_2_0_1 = (RuleCall)cParamsParameterCrossReference_3_2_0.eContents().get(1);
		private final Group cGroup_3_3 = (Group)cGroup_3.eContents().get(3);
		private final Keyword cCommaKeyword_3_3_0 = (Keyword)cGroup_3_3.eContents().get(0);
		private final Assignment cParamsAssignment_3_3_1 = (Assignment)cGroup_3_3.eContents().get(1);
		private final CrossReference cParamsParameterCrossReference_3_3_1_0 = (CrossReference)cParamsAssignment_3_3_1.eContents().get(0);
		private final RuleCall cParamsParameterParameterIDParserRuleCall_3_3_1_0_1 = (RuleCall)cParamsParameterCrossReference_3_3_1_0.eContents().get(1);
		private final Assignment cConstraintAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConstraintConstraintOnGroupParserRuleCall_4_0 = (RuleCall)cConstraintAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cActiveKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cActiveAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cActiveWhenConditionalStatementParserRuleCall_5_1_0 = (RuleCall)cActiveAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cGroupsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cGroupsParameterGroupParserRuleCall_6_0 = (RuleCall)cGroupsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ParameterGroup:
		//	"group" name=ID "{" ("params" "=" params+=[Parameter|ParameterID] ("," params+=[Parameter|ParameterID])*)*
		//	constraint=ConstraintOnGroup? ("active" active=WhenConditionalStatement ";")? groups+=ParameterGroup* //  we really want to mix params and groups - 
		//	"}";
		public ParserRule getRule() { return rule; }

		//"group" name=ID "{" ("params" "=" params+=[Parameter|ParameterID] ("," params+=[Parameter|ParameterID])*)*
		//constraint=ConstraintOnGroup? ("active" active=WhenConditionalStatement ";")? groups+=ParameterGroup* //  we really want to mix params and groups - 
		//"}"
		public Group getGroup() { return cGroup; }

		//"group"
		public Keyword getGroupKeyword_0() { return cGroupKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//("params" "=" params+=[Parameter|ParameterID] ("," params+=[Parameter|ParameterID])*)*
		public Group getGroup_3() { return cGroup_3; }

		//"params"
		public Keyword getParamsKeyword_3_0() { return cParamsKeyword_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_1() { return cEqualsSignKeyword_3_1; }

		//params+=[Parameter|ParameterID]
		public Assignment getParamsAssignment_3_2() { return cParamsAssignment_3_2; }

		//[Parameter|ParameterID]
		public CrossReference getParamsParameterCrossReference_3_2_0() { return cParamsParameterCrossReference_3_2_0; }

		//ParameterID
		public RuleCall getParamsParameterParameterIDParserRuleCall_3_2_0_1() { return cParamsParameterParameterIDParserRuleCall_3_2_0_1; }

		//("," params+=[Parameter|ParameterID])*
		public Group getGroup_3_3() { return cGroup_3_3; }

		//","
		public Keyword getCommaKeyword_3_3_0() { return cCommaKeyword_3_3_0; }

		//params+=[Parameter|ParameterID]
		public Assignment getParamsAssignment_3_3_1() { return cParamsAssignment_3_3_1; }

		//[Parameter|ParameterID]
		public CrossReference getParamsParameterCrossReference_3_3_1_0() { return cParamsParameterCrossReference_3_3_1_0; }

		//ParameterID
		public RuleCall getParamsParameterParameterIDParserRuleCall_3_3_1_0_1() { return cParamsParameterParameterIDParserRuleCall_3_3_1_0_1; }

		//constraint=ConstraintOnGroup?
		public Assignment getConstraintAssignment_4() { return cConstraintAssignment_4; }

		//ConstraintOnGroup
		public RuleCall getConstraintConstraintOnGroupParserRuleCall_4_0() { return cConstraintConstraintOnGroupParserRuleCall_4_0; }

		//("active" active=WhenConditionalStatement ";")?
		public Group getGroup_5() { return cGroup_5; }

		//"active"
		public Keyword getActiveKeyword_5_0() { return cActiveKeyword_5_0; }

		//active=WhenConditionalStatement
		public Assignment getActiveAssignment_5_1() { return cActiveAssignment_5_1; }

		//WhenConditionalStatement
		public RuleCall getActiveWhenConditionalStatementParserRuleCall_5_1_0() { return cActiveWhenConditionalStatementParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5_2() { return cSemicolonKeyword_5_2; }

		//groups+=ParameterGroup*
		public Assignment getGroupsAssignment_6() { return cGroupsAssignment_6; }

		//ParameterGroup
		public RuleCall getGroupsParameterGroupParserRuleCall_6_0() { return cGroupsParameterGroupParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class ConstraintOnGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstraintOnGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementsConditionalStatementParserRuleCall_1_1_0 = (RuleCall)cStatementsAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//ConstraintOnGroup: //perhaps put in some lex syntax here... IMPL.
		//	"constraints " ("[" statements+=ConditionalStatement "]")+;
		public ParserRule getRule() { return rule; }

		////perhaps put in some lex syntax here... IMPL.
		//"constraints " ("[" statements+=ConditionalStatement "]")+
		public Group getGroup() { return cGroup; }

		////perhaps put in some lex syntax here... IMPL.
		//"constraints "
		public Keyword getConstraintsKeyword_0() { return cConstraintsKeyword_0; }

		//("[" statements+=ConditionalStatement "]")+
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//statements+=ConditionalStatement
		public Assignment getStatementsAssignment_1_1() { return cStatementsAssignment_1_1; }

		//ConditionalStatement
		public RuleCall getStatementsConditionalStatementParserRuleCall_1_1_0() { return cStatementsConditionalStatementParserRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class ConditionalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAlwaysConditionalStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfThenConditionalStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cWhenConditionalStatementParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cCommentAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cCommentAssignment_2_1.eContents().get(0);
		
		//ConditionalStatement:
		//	AlwaysConditionalStatement | IfThenConditionalStatement | WhenConditionalStatement comment=STRING?;
		public ParserRule getRule() { return rule; }

		//AlwaysConditionalStatement | IfThenConditionalStatement | WhenConditionalStatement comment=STRING?
		public Alternatives getAlternatives() { return cAlternatives; }

		//AlwaysConditionalStatement
		public RuleCall getAlwaysConditionalStatementParserRuleCall_0() { return cAlwaysConditionalStatementParserRuleCall_0; }

		//IfThenConditionalStatement
		public RuleCall getIfThenConditionalStatementParserRuleCall_1() { return cIfThenConditionalStatementParserRuleCall_1; }

		//WhenConditionalStatement comment=STRING?
		public Group getGroup_2() { return cGroup_2; }

		//WhenConditionalStatement
		public RuleCall getWhenConditionalStatementParserRuleCall_2_0() { return cWhenConditionalStatementParserRuleCall_2_0; }

		//comment=STRING?
		public Assignment getCommentAssignment_2_1() { return cCommentAssignment_2_1; }

		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_2_1_0() { return cCommentSTRINGTerminalRuleCall_2_1_0; }
	}

	public class WhenConditionalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhenConditionalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCriterionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCriterionConditionalClauseParserRuleCall_1_0 = (RuleCall)cCriterionAssignment_1.eContents().get(0);
		
		//WhenConditionalStatement:
		//	"when" criterion=ConditionalClause;
		public ParserRule getRule() { return rule; }

		//"when" criterion=ConditionalClause
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//criterion=ConditionalClause
		public Assignment getCriterionAssignment_1() { return cCriterionAssignment_1; }

		//ConditionalClause
		public RuleCall getCriterionConditionalClauseParserRuleCall_1_0() { return cCriterionConditionalClauseParserRuleCall_1_0; }
	}

	public class IfThenConditionalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfThenConditionalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCriterionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCriterionConditionalClauseParserRuleCall_1_0 = (RuleCall)cCriterionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClauseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cClauseConditionalClauseParserRuleCall_3_0 = (RuleCall)cClauseAssignment_3.eContents().get(0);
		
		//IfThenConditionalStatement:
		//	"if" criterion=ConditionalClause "then" clause=ConditionalClause;
		public ParserRule getRule() { return rule; }

		//"if" criterion=ConditionalClause "then" clause=ConditionalClause
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//criterion=ConditionalClause
		public Assignment getCriterionAssignment_1() { return cCriterionAssignment_1; }

		//ConditionalClause
		public RuleCall getCriterionConditionalClauseParserRuleCall_1_0() { return cCriterionConditionalClauseParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//clause=ConditionalClause
		public Assignment getClauseAssignment_3() { return cClauseAssignment_3; }

		//ConditionalClause
		public RuleCall getClauseConditionalClauseParserRuleCall_3_0() { return cClauseConditionalClauseParserRuleCall_3_0; }
	}

	public class ConditionalClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTerminalClauseParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCriterionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cConnAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConnLogicalConnectorEnumRuleCall_1_1_0 = (RuleCall)cConnAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTerminalClauseParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ConditionalClause:
		//	TerminalClause ({Criterion.left=current} => conn=LogicalConnector right=TerminalClause)?;
		public ParserRule getRule() { return rule; }

		//TerminalClause ({Criterion.left=current} => conn=LogicalConnector right=TerminalClause)?
		public Group getGroup() { return cGroup; }

		//TerminalClause
		public RuleCall getTerminalClauseParserRuleCall_0() { return cTerminalClauseParserRuleCall_0; }

		//({Criterion.left=current} => conn=LogicalConnector right=TerminalClause)?
		public Group getGroup_1() { return cGroup_1; }

		//{Criterion.left=current}
		public Action getCriterionLeftAction_1_0() { return cCriterionLeftAction_1_0; }

		//=> conn=LogicalConnector
		public Assignment getConnAssignment_1_1() { return cConnAssignment_1_1; }

		//LogicalConnector
		public RuleCall getConnLogicalConnectorEnumRuleCall_1_1_0() { return cConnLogicalConnectorEnumRuleCall_1_1_0; }

		//right=TerminalClause
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//TerminalClause
		public RuleCall getRightTerminalClauseParserRuleCall_1_2_0() { return cRightTerminalClauseParserRuleCall_1_2_0; }
	}

	public class TerminalClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TerminalClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExprAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExprExpressionParserRuleCall_0_0 = (RuleCall)cExprAssignment_0.eContents().get(0);
		private final Assignment cCondAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCondConditionParserRuleCall_1_0 = (RuleCall)cCondAssignment_1.eContents().get(0);
		
		//TerminalClause returns ConditionalClause:
		//	expr=Expression cond=Condition;
		public ParserRule getRule() { return rule; }

		//expr=Expression cond=Condition
		public Group getGroup() { return cGroup; }

		//expr=Expression
		public Assignment getExprAssignment_0() { return cExprAssignment_0; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_0_0() { return cExprExpressionParserRuleCall_0_0; }

		//cond=Condition
		public Assignment getCondAssignment_1() { return cCondAssignment_1; }

		//Condition
		public RuleCall getCondConditionParserRuleCall_1_0() { return cCondConditionParserRuleCall_1_0; }
	}

	public class AlwaysConditionalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlwaysConditionalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClauseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClauseConditionalClauseParserRuleCall_1_0 = (RuleCall)cClauseAssignment_1.eContents().get(0);
		
		//AlwaysConditionalStatement:
		//	"assert" clause=ConditionalClause;
		public ParserRule getRule() { return rule; }

		//"assert" clause=ConditionalClause
		public Group getGroup() { return cGroup; }

		//"assert"
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }

		//clause=ConditionalClause
		public Assignment getClauseAssignment_1() { return cClauseAssignment_1; }

		//ConditionalClause
		public RuleCall getClauseConditionalClauseParserRuleCall_1_0() { return cClauseConditionalClauseParserRuleCall_1_0; }
	}

	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Condition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIsNullParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBelongsToSetParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDefaultValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIsIntegerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIsRationalParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIsRealParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cValueDifferentFromParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cValueInRangeParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cValueSmallerThanParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cValueLargerThanParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//Condition:
		//	isNull | BelongsToSet | defaultValue | isInteger | isRational | isReal | ValueDifferentFrom | ValueInRange |
		//	ValueSmallerThan | ValueLargerThan;
		public ParserRule getRule() { return rule; }

		//isNull | BelongsToSet | defaultValue | isInteger | isRational | isReal | ValueDifferentFrom | ValueInRange |
		//ValueSmallerThan | ValueLargerThan
		public Alternatives getAlternatives() { return cAlternatives; }

		//isNull
		public RuleCall getIsNullParserRuleCall_0() { return cIsNullParserRuleCall_0; }

		//BelongsToSet
		public RuleCall getBelongsToSetParserRuleCall_1() { return cBelongsToSetParserRuleCall_1; }

		//defaultValue
		public RuleCall getDefaultValueParserRuleCall_2() { return cDefaultValueParserRuleCall_2; }

		//isInteger
		public RuleCall getIsIntegerParserRuleCall_3() { return cIsIntegerParserRuleCall_3; }

		//isRational
		public RuleCall getIsRationalParserRuleCall_4() { return cIsRationalParserRuleCall_4; }

		//isReal
		public RuleCall getIsRealParserRuleCall_5() { return cIsRealParserRuleCall_5; }

		//ValueDifferentFrom
		public RuleCall getValueDifferentFromParserRuleCall_6() { return cValueDifferentFromParserRuleCall_6; }

		//ValueInRange
		public RuleCall getValueInRangeParserRuleCall_7() { return cValueInRangeParserRuleCall_7; }

		//ValueSmallerThan
		public RuleCall getValueSmallerThanParserRuleCall_8() { return cValueSmallerThanParserRuleCall_8; }

		//ValueLargerThan
		public RuleCall getValueLargerThanParserRuleCall_9() { return cValueLargerThanParserRuleCall_9; }
	}

	public class ValueLargerThanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueLargerThan");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ValueLargerThan:
		//	">" value=Expression;
		public ParserRule getRule() { return rule; }

		//">" value=Expression
		public Group getGroup() { return cGroup; }

		//">"
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }

		//value=Expression
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0() { return cValueExpressionParserRuleCall_1_0; }
	}

	public class ValueSmallerThanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueSmallerThan");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ValueSmallerThan:
		//	"<" value=Expression;
		public ParserRule getRule() { return rule; }

		//"<" value=Expression
		public Group getGroup() { return cGroup; }

		//"<"
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }

		//value=Expression
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0() { return cValueExpressionParserRuleCall_1_0; }
	}

	public class ValueInRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueInRange");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRangeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInfAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInfExpressionParserRuleCall_3_0 = (RuleCall)cInfAssignment_3.eContents().get(0);
		private final Keyword cFullStopFullStopFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cSupAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cSupExpressionParserRuleCall_5_0 = (RuleCall)cSupAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ValueInRange:
		//	"in" "range" "[" inf=Expression => "..." sup=Expression "]";
		public ParserRule getRule() { return rule; }

		//"in" "range" "[" inf=Expression => "..." sup=Expression "]"
		public Group getGroup() { return cGroup; }

		//"in"
		public Keyword getInKeyword_0() { return cInKeyword_0; }

		//"range"
		public Keyword getRangeKeyword_1() { return cRangeKeyword_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//inf=Expression
		public Assignment getInfAssignment_3() { return cInfAssignment_3; }

		//Expression
		public RuleCall getInfExpressionParserRuleCall_3_0() { return cInfExpressionParserRuleCall_3_0; }

		//=> "..."
		public Keyword getFullStopFullStopFullStopKeyword_4() { return cFullStopFullStopFullStopKeyword_4; }

		//sup=Expression
		public Assignment getSupAssignment_5() { return cSupAssignment_5; }

		//Expression
		public RuleCall getSupExpressionParserRuleCall_5_0() { return cSupExpressionParserRuleCall_5_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}

	public class ValueDifferentFromElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueDifferentFrom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ValueDifferentFrom:
		//	"!=" value=Expression;
		public ParserRule getRule() { return rule; }

		//"!=" value=Expression
		public Group getGroup() { return cGroup; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_0() { return cExclamationMarkEqualsSignKeyword_0; }

		//value=Expression
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0() { return cValueExpressionParserRuleCall_1_0; }
	}

	public class IsRealElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "isReal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsRealAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsRealIsKeyword_0_0 = (Keyword)cIsRealAssignment_0.eContents().get(0);
		private final Keyword cRealKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//isReal:
		//	isReal?="is" "real";
		public ParserRule getRule() { return rule; }

		//isReal?="is" "real"
		public Group getGroup() { return cGroup; }

		//isReal?="is"
		public Assignment getIsRealAssignment_0() { return cIsRealAssignment_0; }

		//"is"
		public Keyword getIsRealIsKeyword_0_0() { return cIsRealIsKeyword_0_0; }

		//"real"
		public Keyword getRealKeyword_1() { return cRealKeyword_1; }
	}

	public class IsRationalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "isRational");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsRationalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsRationalIsKeyword_0_0 = (Keyword)cIsRationalAssignment_0.eContents().get(0);
		private final Keyword cRationalKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//isRational:
		//	isRational?="is" "rational";
		public ParserRule getRule() { return rule; }

		//isRational?="is" "rational"
		public Group getGroup() { return cGroup; }

		//isRational?="is"
		public Assignment getIsRationalAssignment_0() { return cIsRationalAssignment_0; }

		//"is"
		public Keyword getIsRationalIsKeyword_0_0() { return cIsRationalIsKeyword_0_0; }

		//"rational"
		public Keyword getRationalKeyword_1() { return cRationalKeyword_1; }
	}

	public class IsIntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "isInteger");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsIntegerAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsIntegerIsKeyword_0_0 = (Keyword)cIsIntegerAssignment_0.eContents().get(0);
		private final Keyword cIntegerKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//isInteger:
		//	isInteger?="is" "integer";
		public ParserRule getRule() { return rule; }

		//isInteger?="is" "integer"
		public Group getGroup() { return cGroup; }

		//isInteger?="is"
		public Assignment getIsIntegerAssignment_0() { return cIsIntegerAssignment_0; }

		//"is"
		public Keyword getIsIntegerIsKeyword_0_0() { return cIsIntegerIsKeyword_0_0; }

		//"integer"
		public Keyword getIntegerKeyword_1() { return cIntegerKeyword_1; }
	}

	public class DefaultValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "defaultValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//defaultValue:
		//	"default " value=Expression;
		public ParserRule getRule() { return rule; }

		//"default " value=Expression
		public Group getGroup() { return cGroup; }

		//"default "
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }

		//value=Expression
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0() { return cValueExpressionParserRuleCall_1_0; }
	}

	public class BelongsToSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BelongsToSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValuesExpressionParserRuleCall_2_0_0 = (RuleCall)cValuesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValuesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValuesExpressionParserRuleCall_2_1_1_0 = (RuleCall)cValuesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * perhaps should do something different for strings. * / BelongsToSet:
		//	"in" "{" (values+=Expression ("," values+=Expression)*) "}";
		public ParserRule getRule() { return rule; }

		//"in" "{" (values+=Expression ("," values+=Expression)*) "}"
		public Group getGroup() { return cGroup; }

		//"in"
		public Keyword getInKeyword_0() { return cInKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//values+=Expression ("," values+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//values+=Expression
		public Assignment getValuesAssignment_2_0() { return cValuesAssignment_2_0; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_2_0_0() { return cValuesExpressionParserRuleCall_2_0_0; }

		//("," values+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//values+=Expression
		public Assignment getValuesAssignment_2_1_1() { return cValuesAssignment_2_1_1; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_2_1_1_0() { return cValuesExpressionParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class IsNullElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "isNull");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsNullAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsNullIsKeyword_0_0 = (Keyword)cIsNullAssignment_0.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//isNull:
		//	isNull?="is" "null";
		public ParserRule getRule() { return rule; }

		//isNull?="is" "null"
		public Group getGroup() { return cGroup; }

		//isNull?="is"
		public Assignment getIsNullAssignment_0() { return cIsNullAssignment_0; }

		//"is"
		public Keyword getIsNullIsKeyword_0_0() { return cIsNullIsKeyword_0_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameFunctionTypeEnumRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Function:
		//	name=FunctionType "(" expr=Expression ")";
		public ParserRule getRule() { return rule; }

		//name=FunctionType "(" expr=Expression ")"
		public Group getGroup() { return cGroup; }

		//name=FunctionType
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//FunctionType
		public RuleCall getNameFunctionTypeEnumRuleCall_0_0() { return cNameFunctionTypeEnumRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class AtomicParameterExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicParameterExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrefAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cPrefParameterCrossReference_1_0 = (CrossReference)cPrefAssignment_1.eContents().get(0);
		private final RuleCall cPrefParameterParameterIDParserRuleCall_1_0_1 = (RuleCall)cPrefParameterCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCircumflexAccentKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPowerAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_2_1_0 = (RuleCall)cPowerAssignment_2_1.eContents().get(0);
		
		//AtomicParameterExpression:
		//	"$" pref=[Parameter|ParameterID] ("^" power=Expression)?;
		public ParserRule getRule() { return rule; }

		//"$" pref=[Parameter|ParameterID] ("^" power=Expression)?
		public Group getGroup() { return cGroup; }

		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }

		//pref=[Parameter|ParameterID]
		public Assignment getPrefAssignment_1() { return cPrefAssignment_1; }

		//[Parameter|ParameterID]
		public CrossReference getPrefParameterCrossReference_1_0() { return cPrefParameterCrossReference_1_0; }

		//ParameterID
		public RuleCall getPrefParameterParameterIDParserRuleCall_1_0_1() { return cPrefParameterParameterIDParserRuleCall_1_0_1; }

		//("^" power=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//"^"
		public Keyword getCircumflexAccentKeyword_2_0() { return cCircumflexAccentKeyword_2_0; }

		//power=Expression
		public Assignment getPowerAssignment_2_1() { return cPowerAssignment_2_1; }

		//Expression
		public RuleCall getPowerExpressionParserRuleCall_2_1_0() { return cPowerExpressionParserRuleCall_2_1_0; }
	}

	public class AtomicConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicConstantExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cConstAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cConstNumberParserRuleCall_0_0_0 = (RuleCall)cConstAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cPowerAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_0_1_1_0 = (RuleCall)cPowerAssignment_0_1_1.eContents().get(0);
		private final Assignment cStrAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStrSTRINGTerminalRuleCall_1_0 = (RuleCall)cStrAssignment_1.eContents().get(0);
		
		/// *need to make the constant have ability to be all number representations * / AtomicConstantExpression:
		//	const=Number ("^" power=Expression)? | str=STRING;
		public ParserRule getRule() { return rule; }

		//const=Number ("^" power=Expression)? | str=STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//const=Number ("^" power=Expression)?
		public Group getGroup_0() { return cGroup_0; }

		//const=Number
		public Assignment getConstAssignment_0_0() { return cConstAssignment_0_0; }

		//Number
		public RuleCall getConstNumberParserRuleCall_0_0_0() { return cConstNumberParserRuleCall_0_0_0; }

		//("^" power=Expression)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"^"
		public Keyword getCircumflexAccentKeyword_0_1_0() { return cCircumflexAccentKeyword_0_1_0; }

		//power=Expression
		public Assignment getPowerAssignment_0_1_1() { return cPowerAssignment_0_1_1; }

		//Expression
		public RuleCall getPowerExpressionParserRuleCall_0_1_1_0() { return cPowerExpressionParserRuleCall_0_1_1_0; }

		//str=STRING
		public Assignment getStrAssignment_1() { return cStrAssignment_1; }

		//STRING
		public RuleCall getStrSTRINGTerminalRuleCall_1_0() { return cStrSTRINGTerminalRuleCall_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTerminalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cOperationLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpOperationTypeEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightTerminalExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		/// * some parser trickery to avoid left recursion * / Expression:
		//	TerminalExpression -> ({Operation.left=current} op=OperationType right=TerminalExpression)?;
		public ParserRule getRule() { return rule; }

		//TerminalExpression -> ({Operation.left=current} op=OperationType right=TerminalExpression)?
		public Group getGroup() { return cGroup; }

		//TerminalExpression
		public RuleCall getTerminalExpressionParserRuleCall_0() { return cTerminalExpressionParserRuleCall_0; }

		//-> ({Operation.left=current} op=OperationType right=TerminalExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{Operation.left=current} op=OperationType right=TerminalExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Operation.left=current}
		public Action getOperationLeftAction_1_0_0() { return cOperationLeftAction_1_0_0; }

		//op=OperationType
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//OperationType
		public RuleCall getOpOperationTypeEnumRuleCall_1_0_1_0() { return cOpOperationTypeEnumRuleCall_1_0_1_0; }

		//right=TerminalExpression
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//TerminalExpression
		public RuleCall getRightTerminalExpressionParserRuleCall_1_0_2_0() { return cRightTerminalExpressionParserRuleCall_1_0_2_0; }
	}

	public class TerminalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TerminalExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenthesisContentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAtomicConstantExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAtomicParameterExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFunctionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TerminalExpression returns Expression:
		//	ParenthesisContent | AtomicConstantExpression | AtomicParameterExpression | Function;
		public ParserRule getRule() { return rule; }

		//ParenthesisContent | AtomicConstantExpression | AtomicParameterExpression | Function
		public Alternatives getAlternatives() { return cAlternatives; }

		//ParenthesisContent
		public RuleCall getParenthesisContentParserRuleCall_0() { return cParenthesisContentParserRuleCall_0; }

		//AtomicConstantExpression
		public RuleCall getAtomicConstantExpressionParserRuleCall_1() { return cAtomicConstantExpressionParserRuleCall_1; }

		//AtomicParameterExpression
		public RuleCall getAtomicParameterExpressionParserRuleCall_2() { return cAtomicParameterExpressionParserRuleCall_2; }

		//Function
		public RuleCall getFunctionParserRuleCall_3() { return cFunctionParserRuleCall_3; }
	}

	public class ParenthesisContentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesisContent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCircumflexAccentKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cPowerAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_3_1_0 = (RuleCall)cPowerAssignment_3_1.eContents().get(0);
		
		//ParenthesisContent:
		//	"(" expr=Expression ")" ("^" power=Expression)?;
		public ParserRule getRule() { return rule; }

		//"(" expr=Expression ")" ("^" power=Expression)?
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }

		//("^" power=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"^"
		public Keyword getCircumflexAccentKeyword_3_0() { return cCircumflexAccentKeyword_3_0; }

		//power=Expression
		public Assignment getPowerAssignment_3_1() { return cPowerAssignment_3_1; }

		//Expression
		public RuleCall getPowerExpressionParserRuleCall_3_1_0() { return cPowerExpressionParserRuleCall_3_1_0; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTEGERParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFLOATTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Number hidden():
		//	INTEGER | FLOAT;
		public ParserRule getRule() { return rule; }

		//INTEGER | FLOAT
		public Alternatives getAlternatives() { return cAlternatives; }

		//INTEGER
		public RuleCall getINTEGERParserRuleCall_0() { return cINTEGERParserRuleCall_0; }

		//FLOAT
		public RuleCall getFLOATTerminalRuleCall_1() { return cFLOATTerminalRuleCall_1; }
	}

	public class INTEGERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INTEGER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////signed as a grammar rule rather than a terminal
		//INTEGER returns ecore::EInt:
		//	("+" | "-")? INT;
		public ParserRule getRule() { return rule; }

		//("+" | "-")? INT
		public Group getGroup() { return cGroup; }

		//("+" | "-")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"+"
		public Keyword getPlusSignKeyword_0_0() { return cPlusSignKeyword_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	public class ParameterTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBooleanBooleanKeyword_0_0 = (Keyword)cBooleanEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cStringStringKeyword_1_0 = (Keyword)cStringEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cIntegerEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cIntegerIntegerKeyword_2_0 = (Keyword)cIntegerEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cRealEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cRealRealKeyword_3_0 = (Keyword)cRealEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cDateEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cDateDateKeyword_4_0 = (Keyword)cDateEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum ParameterType:
		//	boolean | string | integer | real | date;
		public EnumRule getRule() { return rule; }

		//boolean | string | integer | real | date
		public Alternatives getAlternatives() { return cAlternatives; }

		//boolean
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_0() { return cBooleanEnumLiteralDeclaration_0; }

		//"boolean"
		public Keyword getBooleanBooleanKeyword_0_0() { return cBooleanBooleanKeyword_0_0; }

		//string
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_1() { return cStringEnumLiteralDeclaration_1; }

		//"string"
		public Keyword getStringStringKeyword_1_0() { return cStringStringKeyword_1_0; }

		//integer
		public EnumLiteralDeclaration getIntegerEnumLiteralDeclaration_2() { return cIntegerEnumLiteralDeclaration_2; }

		//"integer"
		public Keyword getIntegerIntegerKeyword_2_0() { return cIntegerIntegerKeyword_2_0; }

		//real
		public EnumLiteralDeclaration getRealEnumLiteralDeclaration_3() { return cRealEnumLiteralDeclaration_3; }

		//"real"
		public Keyword getRealRealKeyword_3_0() { return cRealRealKeyword_3_0; }

		//date
		public EnumLiteralDeclaration getDateEnumLiteralDeclaration_4() { return cDateEnumLiteralDeclaration_4; }

		//"date"
		public Keyword getDateDateKeyword_4_0() { return cDateDateKeyword_4_0; }
	}

	public class FunctionTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSizeEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSizeSizeKeyword_0_0 = (Keyword)cSizeEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAbsEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAbsAbsKeyword_1_0 = (Keyword)cAbsEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSinEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSinSinKeyword_2_0 = (Keyword)cSinEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCosEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCosCosKeyword_3_0 = (Keyword)cCosEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTanEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTanTanKeyword_4_0 = (Keyword)cTanEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cAsinEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cAsinAsinKeyword_5_0 = (Keyword)cAsinEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cAcosEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cAcosAcosKeyword_6_0 = (Keyword)cAcosEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cAtanEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cAtanAtanKeyword_7_0 = (Keyword)cAtanEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cExpEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cExpExpKeyword_8_0 = (Keyword)cExpEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cLogEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cLogLogKeyword_9_0 = (Keyword)cLogEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cSumEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cSumSumKeyword_10_0 = (Keyword)cSumEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cProductEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cProductProductKeyword_11_0 = (Keyword)cProductEnumLiteralDeclaration_11.eContents().get(0);
		
		//enum FunctionType:
		//	size | abs | sin | cos | tan | asin | acos | atan | exp | log | sum | product;
		public EnumRule getRule() { return rule; }

		//size | abs | sin | cos | tan | asin | acos | atan | exp | log | sum | product
		public Alternatives getAlternatives() { return cAlternatives; }

		//size
		public EnumLiteralDeclaration getSizeEnumLiteralDeclaration_0() { return cSizeEnumLiteralDeclaration_0; }

		//"size"
		public Keyword getSizeSizeKeyword_0_0() { return cSizeSizeKeyword_0_0; }

		//abs
		public EnumLiteralDeclaration getAbsEnumLiteralDeclaration_1() { return cAbsEnumLiteralDeclaration_1; }

		//"abs"
		public Keyword getAbsAbsKeyword_1_0() { return cAbsAbsKeyword_1_0; }

		//sin
		public EnumLiteralDeclaration getSinEnumLiteralDeclaration_2() { return cSinEnumLiteralDeclaration_2; }

		//"sin"
		public Keyword getSinSinKeyword_2_0() { return cSinSinKeyword_2_0; }

		//cos
		public EnumLiteralDeclaration getCosEnumLiteralDeclaration_3() { return cCosEnumLiteralDeclaration_3; }

		//"cos"
		public Keyword getCosCosKeyword_3_0() { return cCosCosKeyword_3_0; }

		//tan
		public EnumLiteralDeclaration getTanEnumLiteralDeclaration_4() { return cTanEnumLiteralDeclaration_4; }

		//"tan"
		public Keyword getTanTanKeyword_4_0() { return cTanTanKeyword_4_0; }

		//asin
		public EnumLiteralDeclaration getAsinEnumLiteralDeclaration_5() { return cAsinEnumLiteralDeclaration_5; }

		//"asin"
		public Keyword getAsinAsinKeyword_5_0() { return cAsinAsinKeyword_5_0; }

		//acos
		public EnumLiteralDeclaration getAcosEnumLiteralDeclaration_6() { return cAcosEnumLiteralDeclaration_6; }

		//"acos"
		public Keyword getAcosAcosKeyword_6_0() { return cAcosAcosKeyword_6_0; }

		//atan
		public EnumLiteralDeclaration getAtanEnumLiteralDeclaration_7() { return cAtanEnumLiteralDeclaration_7; }

		//"atan"
		public Keyword getAtanAtanKeyword_7_0() { return cAtanAtanKeyword_7_0; }

		//exp
		public EnumLiteralDeclaration getExpEnumLiteralDeclaration_8() { return cExpEnumLiteralDeclaration_8; }

		//"exp"
		public Keyword getExpExpKeyword_8_0() { return cExpExpKeyword_8_0; }

		//log
		public EnumLiteralDeclaration getLogEnumLiteralDeclaration_9() { return cLogEnumLiteralDeclaration_9; }

		//"log"
		public Keyword getLogLogKeyword_9_0() { return cLogLogKeyword_9_0; }

		//sum
		public EnumLiteralDeclaration getSumEnumLiteralDeclaration_10() { return cSumEnumLiteralDeclaration_10; }

		//"sum"
		public Keyword getSumSumKeyword_10_0() { return cSumSumKeyword_10_0; }

		//product
		public EnumLiteralDeclaration getProductEnumLiteralDeclaration_11() { return cProductEnumLiteralDeclaration_11; }

		//"product"
		public Keyword getProductProductKeyword_11_0() { return cProductProductKeyword_11_0; }
	}

	public class OperationTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "OperationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMULTIPLYEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMULTIPLYAsteriskKeyword_2_0 = (Keyword)cMULTIPLYEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDIVIDEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDIVIDESolidusKeyword_3_0 = (Keyword)cDIVIDEEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSCALAREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSCALARFullStopKeyword_4_0 = (Keyword)cSCALAREnumLiteralDeclaration_4.eContents().get(0);
		
		//enum OperationType:
		//	PLUS="+" | MINUS="-" | MULTIPLY="*" | DIVIDE="/" | SCALAR=".";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-" | MULTIPLY="*" | DIVIDE="/" | SCALAR="."
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }

		//MULTIPLY="*"
		public EnumLiteralDeclaration getMULTIPLYEnumLiteralDeclaration_2() { return cMULTIPLYEnumLiteralDeclaration_2; }

		//"*"
		public Keyword getMULTIPLYAsteriskKeyword_2_0() { return cMULTIPLYAsteriskKeyword_2_0; }

		//DIVIDE="/"
		public EnumLiteralDeclaration getDIVIDEEnumLiteralDeclaration_3() { return cDIVIDEEnumLiteralDeclaration_3; }

		//"/"
		public Keyword getDIVIDESolidusKeyword_3_0() { return cDIVIDESolidusKeyword_3_0; }

		//SCALAR="."
		public EnumLiteralDeclaration getSCALAREnumLiteralDeclaration_4() { return cSCALAREnumLiteralDeclaration_4; }

		//"."
		public Keyword getSCALARFullStopKeyword_4_0() { return cSCALARFullStopKeyword_4_0; }
	}

	public class LogicalConnectorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalConnector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDAndKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOROrKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum LogicalConnector:
		//	AND="and" | OR="or";
		public EnumRule getRule() { return rule; }

		//AND="and" | OR="or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AND="and"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }

		//"and"
		public Keyword getANDAndKeyword_0_0() { return cANDAndKeyword_0_0; }

		//OR="or"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"or"
		public Keyword getOROrKeyword_1_0() { return cOROrKeyword_1_0; }
	}
	
	private PDLElements pPDL;
	private ServiceElements pService;
	private ParameterIDElements pParameterID;
	private ParameterElements pParameter;
	private ParameterTypeElements unknownRuleParameterType;
	private ParameterGroupElements pParameterGroup;
	private ConstraintOnGroupElements pConstraintOnGroup;
	private ConditionalStatementElements pConditionalStatement;
	private WhenConditionalStatementElements pWhenConditionalStatement;
	private IfThenConditionalStatementElements pIfThenConditionalStatement;
	private ConditionalClauseElements pConditionalClause;
	private TerminalClauseElements pTerminalClause;
	private AlwaysConditionalStatementElements pAlwaysConditionalStatement;
	private ConditionElements pCondition;
	private ValueLargerThanElements pValueLargerThan;
	private ValueSmallerThanElements pValueSmallerThan;
	private ValueInRangeElements pValueInRange;
	private ValueDifferentFromElements pValueDifferentFrom;
	private IsRealElements pIsReal;
	private IsRationalElements pIsRational;
	private IsIntegerElements pIsInteger;
	private DefaultValueElements pDefaultValue;
	private BelongsToSetElements pBelongsToSet;
	private IsNullElements pIsNull;
	private FunctionElements pFunction;
	private FunctionTypeElements unknownRuleFunctionType;
	private AtomicParameterExpressionElements pAtomicParameterExpression;
	private AtomicConstantExpressionElements pAtomicConstantExpression;
	private ExpressionElements pExpression;
	private TerminalExpressionElements pTerminalExpression;
	private ParenthesisContentElements pParenthesisContent;
	private OperationTypeElements unknownRuleOperationType;
	private LogicalConnectorElements unknownRuleLogicalConnector;
	private NumberElements pNumber;
	private INTEGERElements pINTEGER;
	private TerminalRule tFLOAT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public PdlsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.ivoa.pdl.pdls.Pdls".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	// * domain specific language for PDL
	// * / PDL:
	//	Service;
	public PDLElements getPDLAccess() {
		return (pPDL != null) ? pPDL : (pPDL = new PDLElements());
	}
	
	public ParserRule getPDLRule() {
		return getPDLAccess().getRule();
	}

	//Service:
	//	"service" name=ID "{" "parameters" "{" parameters+=Parameter+ "}" "input" "{" inputs+=ParameterGroup* "}" "output" "{"
	//	outputs+=ParameterGroup* "}" "}";
	public ServiceElements getServiceAccess() {
		return (pService != null) ? pService : (pService = new ServiceElements());
	}
	
	public ParserRule getServiceRule() {
		return getServiceAccess().getRule();
	}

	/// * * / ParameterID:
	//	ID;
	public ParameterIDElements getParameterIDAccess() {
		return (pParameterID != null) ? pParameterID : (pParameterID = new ParameterIDElements());
	}
	
	public ParserRule getParameterIDRule() {
		return getParameterIDAccess().getRule();
	}

	/// * include restriction of always conditional statement as convenience to ba applied everywhere - should not reference other parameters * /
	//Parameter:
	//	name=ParameterID ":" type=ParameterType ";";
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//enum ParameterType:
	//	boolean | string | integer | real | date;
	public ParameterTypeElements getParameterTypeAccess() {
		return (unknownRuleParameterType != null) ? unknownRuleParameterType : (unknownRuleParameterType = new ParameterTypeElements());
	}
	
	public EnumRule getParameterTypeRule() {
		return getParameterTypeAccess().getRule();
	}

	//ParameterGroup:
	//	"group" name=ID "{" ("params" "=" params+=[Parameter|ParameterID] ("," params+=[Parameter|ParameterID])*)*
	//	constraint=ConstraintOnGroup? ("active" active=WhenConditionalStatement ";")? groups+=ParameterGroup* //  we really want to mix params and groups - 
	//	"}";
	public ParameterGroupElements getParameterGroupAccess() {
		return (pParameterGroup != null) ? pParameterGroup : (pParameterGroup = new ParameterGroupElements());
	}
	
	public ParserRule getParameterGroupRule() {
		return getParameterGroupAccess().getRule();
	}

	//ConstraintOnGroup: //perhaps put in some lex syntax here... IMPL.
	//	"constraints " ("[" statements+=ConditionalStatement "]")+;
	public ConstraintOnGroupElements getConstraintOnGroupAccess() {
		return (pConstraintOnGroup != null) ? pConstraintOnGroup : (pConstraintOnGroup = new ConstraintOnGroupElements());
	}
	
	public ParserRule getConstraintOnGroupRule() {
		return getConstraintOnGroupAccess().getRule();
	}

	//ConditionalStatement:
	//	AlwaysConditionalStatement | IfThenConditionalStatement | WhenConditionalStatement comment=STRING?;
	public ConditionalStatementElements getConditionalStatementAccess() {
		return (pConditionalStatement != null) ? pConditionalStatement : (pConditionalStatement = new ConditionalStatementElements());
	}
	
	public ParserRule getConditionalStatementRule() {
		return getConditionalStatementAccess().getRule();
	}

	//WhenConditionalStatement:
	//	"when" criterion=ConditionalClause;
	public WhenConditionalStatementElements getWhenConditionalStatementAccess() {
		return (pWhenConditionalStatement != null) ? pWhenConditionalStatement : (pWhenConditionalStatement = new WhenConditionalStatementElements());
	}
	
	public ParserRule getWhenConditionalStatementRule() {
		return getWhenConditionalStatementAccess().getRule();
	}

	//IfThenConditionalStatement:
	//	"if" criterion=ConditionalClause "then" clause=ConditionalClause;
	public IfThenConditionalStatementElements getIfThenConditionalStatementAccess() {
		return (pIfThenConditionalStatement != null) ? pIfThenConditionalStatement : (pIfThenConditionalStatement = new IfThenConditionalStatementElements());
	}
	
	public ParserRule getIfThenConditionalStatementRule() {
		return getIfThenConditionalStatementAccess().getRule();
	}

	//ConditionalClause:
	//	TerminalClause ({Criterion.left=current} => conn=LogicalConnector right=TerminalClause)?;
	public ConditionalClauseElements getConditionalClauseAccess() {
		return (pConditionalClause != null) ? pConditionalClause : (pConditionalClause = new ConditionalClauseElements());
	}
	
	public ParserRule getConditionalClauseRule() {
		return getConditionalClauseAccess().getRule();
	}

	//TerminalClause returns ConditionalClause:
	//	expr=Expression cond=Condition;
	public TerminalClauseElements getTerminalClauseAccess() {
		return (pTerminalClause != null) ? pTerminalClause : (pTerminalClause = new TerminalClauseElements());
	}
	
	public ParserRule getTerminalClauseRule() {
		return getTerminalClauseAccess().getRule();
	}

	//AlwaysConditionalStatement:
	//	"assert" clause=ConditionalClause;
	public AlwaysConditionalStatementElements getAlwaysConditionalStatementAccess() {
		return (pAlwaysConditionalStatement != null) ? pAlwaysConditionalStatement : (pAlwaysConditionalStatement = new AlwaysConditionalStatementElements());
	}
	
	public ParserRule getAlwaysConditionalStatementRule() {
		return getAlwaysConditionalStatementAccess().getRule();
	}

	//Condition:
	//	isNull | BelongsToSet | defaultValue | isInteger | isRational | isReal | ValueDifferentFrom | ValueInRange |
	//	ValueSmallerThan | ValueLargerThan;
	public ConditionElements getConditionAccess() {
		return (pCondition != null) ? pCondition : (pCondition = new ConditionElements());
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}

	//ValueLargerThan:
	//	">" value=Expression;
	public ValueLargerThanElements getValueLargerThanAccess() {
		return (pValueLargerThan != null) ? pValueLargerThan : (pValueLargerThan = new ValueLargerThanElements());
	}
	
	public ParserRule getValueLargerThanRule() {
		return getValueLargerThanAccess().getRule();
	}

	//ValueSmallerThan:
	//	"<" value=Expression;
	public ValueSmallerThanElements getValueSmallerThanAccess() {
		return (pValueSmallerThan != null) ? pValueSmallerThan : (pValueSmallerThan = new ValueSmallerThanElements());
	}
	
	public ParserRule getValueSmallerThanRule() {
		return getValueSmallerThanAccess().getRule();
	}

	//ValueInRange:
	//	"in" "range" "[" inf=Expression => "..." sup=Expression "]";
	public ValueInRangeElements getValueInRangeAccess() {
		return (pValueInRange != null) ? pValueInRange : (pValueInRange = new ValueInRangeElements());
	}
	
	public ParserRule getValueInRangeRule() {
		return getValueInRangeAccess().getRule();
	}

	//ValueDifferentFrom:
	//	"!=" value=Expression;
	public ValueDifferentFromElements getValueDifferentFromAccess() {
		return (pValueDifferentFrom != null) ? pValueDifferentFrom : (pValueDifferentFrom = new ValueDifferentFromElements());
	}
	
	public ParserRule getValueDifferentFromRule() {
		return getValueDifferentFromAccess().getRule();
	}

	//isReal:
	//	isReal?="is" "real";
	public IsRealElements getIsRealAccess() {
		return (pIsReal != null) ? pIsReal : (pIsReal = new IsRealElements());
	}
	
	public ParserRule getIsRealRule() {
		return getIsRealAccess().getRule();
	}

	//isRational:
	//	isRational?="is" "rational";
	public IsRationalElements getIsRationalAccess() {
		return (pIsRational != null) ? pIsRational : (pIsRational = new IsRationalElements());
	}
	
	public ParserRule getIsRationalRule() {
		return getIsRationalAccess().getRule();
	}

	//isInteger:
	//	isInteger?="is" "integer";
	public IsIntegerElements getIsIntegerAccess() {
		return (pIsInteger != null) ? pIsInteger : (pIsInteger = new IsIntegerElements());
	}
	
	public ParserRule getIsIntegerRule() {
		return getIsIntegerAccess().getRule();
	}

	//defaultValue:
	//	"default " value=Expression;
	public DefaultValueElements getDefaultValueAccess() {
		return (pDefaultValue != null) ? pDefaultValue : (pDefaultValue = new DefaultValueElements());
	}
	
	public ParserRule getDefaultValueRule() {
		return getDefaultValueAccess().getRule();
	}

	/// * perhaps should do something different for strings. * / BelongsToSet:
	//	"in" "{" (values+=Expression ("," values+=Expression)*) "}";
	public BelongsToSetElements getBelongsToSetAccess() {
		return (pBelongsToSet != null) ? pBelongsToSet : (pBelongsToSet = new BelongsToSetElements());
	}
	
	public ParserRule getBelongsToSetRule() {
		return getBelongsToSetAccess().getRule();
	}

	//isNull:
	//	isNull?="is" "null";
	public IsNullElements getIsNullAccess() {
		return (pIsNull != null) ? pIsNull : (pIsNull = new IsNullElements());
	}
	
	public ParserRule getIsNullRule() {
		return getIsNullAccess().getRule();
	}

	//Function:
	//	name=FunctionType "(" expr=Expression ")";
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//enum FunctionType:
	//	size | abs | sin | cos | tan | asin | acos | atan | exp | log | sum | product;
	public FunctionTypeElements getFunctionTypeAccess() {
		return (unknownRuleFunctionType != null) ? unknownRuleFunctionType : (unknownRuleFunctionType = new FunctionTypeElements());
	}
	
	public EnumRule getFunctionTypeRule() {
		return getFunctionTypeAccess().getRule();
	}

	//AtomicParameterExpression:
	//	"$" pref=[Parameter|ParameterID] ("^" power=Expression)?;
	public AtomicParameterExpressionElements getAtomicParameterExpressionAccess() {
		return (pAtomicParameterExpression != null) ? pAtomicParameterExpression : (pAtomicParameterExpression = new AtomicParameterExpressionElements());
	}
	
	public ParserRule getAtomicParameterExpressionRule() {
		return getAtomicParameterExpressionAccess().getRule();
	}

	/// *need to make the constant have ability to be all number representations * / AtomicConstantExpression:
	//	const=Number ("^" power=Expression)? | str=STRING;
	public AtomicConstantExpressionElements getAtomicConstantExpressionAccess() {
		return (pAtomicConstantExpression != null) ? pAtomicConstantExpression : (pAtomicConstantExpression = new AtomicConstantExpressionElements());
	}
	
	public ParserRule getAtomicConstantExpressionRule() {
		return getAtomicConstantExpressionAccess().getRule();
	}

	/// * some parser trickery to avoid left recursion * / Expression:
	//	TerminalExpression -> ({Operation.left=current} op=OperationType right=TerminalExpression)?;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//TerminalExpression returns Expression:
	//	ParenthesisContent | AtomicConstantExpression | AtomicParameterExpression | Function;
	public TerminalExpressionElements getTerminalExpressionAccess() {
		return (pTerminalExpression != null) ? pTerminalExpression : (pTerminalExpression = new TerminalExpressionElements());
	}
	
	public ParserRule getTerminalExpressionRule() {
		return getTerminalExpressionAccess().getRule();
	}

	//ParenthesisContent:
	//	"(" expr=Expression ")" ("^" power=Expression)?;
	public ParenthesisContentElements getParenthesisContentAccess() {
		return (pParenthesisContent != null) ? pParenthesisContent : (pParenthesisContent = new ParenthesisContentElements());
	}
	
	public ParserRule getParenthesisContentRule() {
		return getParenthesisContentAccess().getRule();
	}

	//enum OperationType:
	//	PLUS="+" | MINUS="-" | MULTIPLY="*" | DIVIDE="/" | SCALAR=".";
	public OperationTypeElements getOperationTypeAccess() {
		return (unknownRuleOperationType != null) ? unknownRuleOperationType : (unknownRuleOperationType = new OperationTypeElements());
	}
	
	public EnumRule getOperationTypeRule() {
		return getOperationTypeAccess().getRule();
	}

	//enum LogicalConnector:
	//	AND="and" | OR="or";
	public LogicalConnectorElements getLogicalConnectorAccess() {
		return (unknownRuleLogicalConnector != null) ? unknownRuleLogicalConnector : (unknownRuleLogicalConnector = new LogicalConnectorElements());
	}
	
	public EnumRule getLogicalConnectorRule() {
		return getLogicalConnectorAccess().getRule();
	}

	//Number hidden():
	//	INTEGER | FLOAT;
	public NumberElements getNumberAccess() {
		return (pNumber != null) ? pNumber : (pNumber = new NumberElements());
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	////signed as a grammar rule rather than a terminal
	//INTEGER returns ecore::EInt:
	//	("+" | "-")? INT;
	public INTEGERElements getINTEGERAccess() {
		return (pINTEGER != null) ? pINTEGER : (pINTEGER = new INTEGERElements());
	}
	
	public ParserRule getINTEGERRule() {
		return getINTEGERAccess().getRule();
	}

	//terminal FLOAT returns ecore::EBigDecimal:
	//	("+" | "-")? (INT "." INT? | "." INT) (("e" | "E") ("+" | "-")? INT)?;
	public TerminalRule getFLOATRule() {
		return (tFLOAT != null) ? tFLOAT : (tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOAT"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
